<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>blockframes documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">blockframes documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>RawOperation</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>libs/organization/src/lib/+state/organization.service.ts</code>
        </p>



        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#active">active</a>
                                </li>
                                <li>
                                        <a href="#name">name</a>
                                </li>
                                <li>
                                        <a href="#quorum">quorum</a>
                                </li>
                                <li>
                                        <a href="#whitelistLength">whitelistLength</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="active"></a>
                                        <span class="name"><b>active</b><a href="#active"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>active:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="name"></a>
                                        <span class="name"><b>name</b><a href="#name"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>name:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="quorum"></a>
                                        <span class="name"><b>quorum</b><a href="#quorum"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>quorum:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="whitelistLength"></a>
                                        <span class="name"><b>whitelistLength</b><a href="#whitelistLength"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>whitelistLength:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import firebase from &#x27;firebase&#x27;;
import { Injectable } from &#x27;@angular/core&#x27;;
import { switchMap, tap } from &#x27;rxjs/operators&#x27;;
import { Observable } from &#x27;rxjs&#x27;;
import {
  FireQuery,
  Query,
  emailToEnsDomain,
  precomputeAddress as precomputeEthAddress,
  getNameFromENS,
  orgNameToEnsDomain } from &#x27;@blockframes/utils&#x27;;
import { AuthQuery, AuthService, AuthStore, User } from &#x27;@blockframes/auth&#x27;;
import { App, createAppPermissions, createPermissions, PermissionsQuery } from &#x27;../permissions/+state&#x27;;
import {
  createOrganization,
  Organization,
  OrganizationMember,
  OrganizationMemberRequest,
  OrganizationOperation,
  OrganizationStatus,
  OrganizationAction
} from &#x27;./organization.model&#x27;;
import { OrganizationStore, DeploySteps } from &#x27;./organization.store&#x27;;
import { OrganizationQuery } from &#x27;./organization.query&#x27;;
import { InfuraProvider } from &#x27;@ethersproject/providers&#x27;;
import { Provider } from &#x27;@ethersproject/providers&#x27;;
import { Contract } from &#x27;@ethersproject/contracts&#x27;;
import { BigNumber } from &#x27;@ethersproject/bignumber&#x27;;
import { Log, Filter } from &#x27;@ethersproject/abstract-provider&#x27;
import { namehash, id as keccak256 } from &#x27;@ethersproject/hash&#x27;;
import { network, relayer, baseEnsDomain } from &#x27;@env&#x27;;
import { abi as ORGANIZATION_ABI } from &#x27;../../../../../contracts/build/Organization.json&#x27;;
import { OrganizationDocument } from &#x27;./organization.firestore&#x27;;

export const orgQuery &#x3D; (orgId: string): Query&lt;Organization&gt; &#x3D;&gt; ({
  path: &#x60;orgs/${orgId}&#x60;,
  members: (organization: Organization) &#x3D;&gt;
    organization.userIds.map(id &#x3D;&gt; ({
      path: &#x60;users/${id}&#x60;
    }))
});

//--------------------------------------
//        ETHEREUM ORGS TYPES
//--------------------------------------
interface RawOperation {
  name: string;
  whitelistLength: string;
  quorum: string;
  active: boolean
}

interface RawAction {
  operationId: string;
  approvalsCount: string;
  active: boolean;
  executed: boolean;
  to: string;
  value: string;
  data: string;
}

//--------------------------------------
//           ETHEREUM TOPICS
//--------------------------------------
const newOwnerTopic         &#x3D; &#x27;0xce0457fe73731f824cc272376169235128c118b49d344817417c6d108d155e82&#x27;;// &#x27;NewOwner (index_topic_1 bytes32 node, index_topic_2 bytes32 label, address owner)&#x27; event
const newResolverTopic      &#x3D; &#x27;0x335721b01866dc23fbee8b6b2c7b1e14d6f05c28cd35a2c934239f94095602a0&#x27;;// &#x27;NewResolver (index_topic_1 bytes32 node, address resolver)&#x27; event
const addrChangedTopic      &#x3D; &#x27;0x52d7d861f09ab3d26239d492e8968629f95e9e318cf0b73bfddc441522a15fd2&#x27;; // &#x27;AddrChanged(byte32,address)&#x27; event
const operationCreatedTopic &#x3D; &#x27;0x46e4d2a30e96e4ccf9e9a058230b32ce42ee291c0f641c93de894fe65c8814b0&#x27;; // &#x27;OperationCreated(uint256)&#x27; event
const quorumUpdatedTopic    &#x3D; &#x27;0x6784e9bcb845caaa98267d7b0918f97d3d17f7cb35a05b52010f7eb587a0acb0&#x27;; // &#x27;QuorumUpdated(uint256,uint256)&#x27; event
const memberAddedTopic      &#x3D; &#x27;0xf328ac0f8bcae00933fe87ba0aa2d0d505c1df94bc9c1aa05b8441c28b74032c&#x27;; // &#x27;MemberAdded(uint256,address)&#x27; event
const memberRemovedTopic    &#x3D; &#x27;0x1c4c9d2e56d0635d11bc47c997c6909a0d7061f55cbb8f4b27386db37553191c&#x27;; // &#x27;MemberRemoved(uint256,address)&#x27; event
const actionApprovedTopic   &#x3D; &#x27;0x4eb2529dfaf5a7847cb1209edb2e7d95cf4c91f833762c3b7234771db8539f9b&#x27;; // &#x27;ActionApproved(bytes32,address)&#x27; event
const actionExecutedTopic   &#x3D; &#x27;0x27bfac0e8b79713f577faf36f24c58597bacaa93ef1b54da177e07bf10b32cb9&#x27;; // &#x27;ActionExecuted(bytes32,bool,bytes)&#x27; event

//--------------------------------------
//     ETHEREUM ORGS EVENT FILTERS
//--------------------------------------
function getFilterFromTopics(address: string, topics: string[]): Filter {
  return {
    address,
    fromBlock: 0, toBlock: &#x27;latest&#x27;,
    topics
  }
}

@Injectable({ providedIn: &#x27;root&#x27; })
export class OrganizationService {
  private organization$: Observable&lt;Organization&gt;;

  private provider: Provider; // we use a different provider than the wallet to easily manage events without having side effects on it
  private contract: Contract;

  constructor(
    private query: OrganizationQuery,
    private store: OrganizationStore,
    private permissionsQuery: PermissionsQuery,
    private authStore: AuthStore,
    private authService: AuthService,
    private authQuery: AuthQuery,
    private db: FireQuery,
  ) {}

  /** Returns an observable over organization, to be reused when you need orgs without guards */
  public sync(): Observable&lt;Organization&gt; {
    // prevent creating multiple side-effecting subs
    if (this.organization$) {
      return this.organization$;
    }

    this.organization$ &#x3D; this.authQuery.user$.pipe(
      switchMap(user &#x3D;&gt; {
        if (!user.orgId) {
          throw new Error(&#x27;User has no orgId&#x27;);
        }
        return this.db.fromQuery&lt;Organization&gt;(orgQuery(user.orgId));
      }),
      tap(organization &#x3D;&gt; this.store.updateOrganization(organization))
    );

    return this.organization$;
  }

  /** Add a new user to the organization */
  public async addMember(member: OrganizationMemberRequest) {
    const orgId &#x3D; this.query.id;
    // get a user or create a ghost user when needed:
    const { uid } &#x3D; await this.authService.getOrCreateUserByMail(member.email); // TODO: limit the number of requests per organizations!

    // TODO: use a definitive data type
    // TODO: compare with backend-functions
    const invitation &#x3D; { userId: uid, orgId, type: &#x27;orgInvitation&#x27;, state: &#x27;pending&#x27; };

    await this.db.collection(&#x27;invitations&#x27;).add(invitation);

    return uid;
  }

  /**
   * Add a new organization to the database and create/update
   * related documents (permissions, apps permissions, user...).
   */
  public async add(organization: Partial&lt;OrganizationDocument&gt;, user: User): Promise&lt;string&gt; {
    const orgId: string &#x3D; this.db.createId();
    const newOrganization: OrganizationDocument &#x3D; createOrganization({
      id: orgId,
      userIds: [user.uid],
      ...organization,
    });
    const organizationDoc &#x3D; this.db.doc(&#x60;orgs/${orgId}&#x60;);
    const permissions &#x3D; createPermissions({ orgId, superAdmins: [user.uid] });
    const permissionsDoc &#x3D; this.db.doc(&#x60;permissions/${orgId}&#x60;);
    const userDoc &#x3D; this.db.doc(&#x60;users/${user.uid}&#x60;);
    const apps: App[] &#x3D; [App.mediaDelivering, App.mediaFinanciers, App.storiesAndMore];

    // Set permissions in the first transaction
    await this.db.firestore.runTransaction(tx &#x3D;&gt;
      Promise.all([
        // Set the new organization in permissions collection.
        tx.set(permissionsDoc.ref, permissions),
        // Initialize apps permissions documents in permissions apps sub-collection.
        ...apps.map(app &#x3D;&gt; {
          const newApp &#x3D; this.db.doc(&#x60;permissions/${orgId}/userAppsPermissions/${app}&#x60;);
          const appPermissions &#x3D; createAppPermissions(app);
          return tx.set(newApp.ref, appPermissions);
        })
      ])
    );

    // Then set organization in the second transaction (rules from permissions will apply)
    await this.db.firestore
      .runTransaction(transaction &#x3D;&gt; {
        const promises &#x3D; [
          // Set the new organization in orgs collection.
          transaction.set(organizationDoc.ref, newOrganization),
          // Update user document with the new organization id.
          transaction.update(userDoc.ref, { orgId })
        ];
        return Promise.all(promises);
      })
      .catch(error &#x3D;&gt; console.error(error));
    this.authStore.updateUser({ ...user, ...{ orgId } });
    return orgId;
  }

  public update(organization: Partial&lt;Organization&gt;) {
    const organizationId &#x3D; this.query.id;
    return this.db.doc(&#x60;orgs/${organizationId}&#x60;).update(organization);
  }

  /** Returns a list of organizations whose part of name match with @param prefix */
  public async getOrganizationsByName(prefix: string): Promise&lt;Organization[]&gt; {
    const call &#x3D; firebase.functions().httpsCallable(&#x27;findOrgByName&#x27;);
    return call({ prefix }).then(matchingOrganizations &#x3D;&gt; matchingOrganizations.data);
  }

  // TODO(#679): somehow the updateActiveMembers array don&#x27;t filter correctly
  // the id out of the activeMembersArray.
  /* public async deleteActiveSigner(member: OrganizationMember) {
  public async deleteActiveSigner(member: OrganizationMember, action: OrganizationActionOld) {
    const organizationId &#x3D; this.query.id;
    const actionData &#x3D; await this.db.snapshot&lt;OrganizationActionOld&gt;(
      &#x60;orgs/${organizationId}/actions/${action.id}&#x60;
    );
    const updatedActiveMembers &#x3D; actionData.activeMembers.filter(
      _member &#x3D;&gt; _member.uid !&#x3D;&#x3D; member.uid
    );
    return this.db
      .doc&lt;OrganizationActionOld&gt;(&#x60;orgs/${organizationId}/actions/${action.id}&#x60;)
      .update({ activeMembers: updatedActiveMembers });
  }*/

  //-------------------------------------------------
  //            BLOCKCHAIN PART OF ORGS
  //-------------------------------------------------

  //------------------------------
  // TUTORIAL on Ethereum events :
  //------------------------------
  // in solidity an event is declared like that :
  //    &#x27;event MemberAdded(uint256 indexed operationId, address indexed member);&#x27;
  //                ^                  ^                          ^
  //              topics[0]        topics[1]                   topics[2]
  //
  // the event name (topics[0]) is the hash of the ABI signature of the event :
  // for the previous event the ABI signature is : &#x27;MemberAdded(uint256,address)&#x27;
  // so topics[0] is : ethers.utils.id(&#x27;MemberAdded(uint256, address)&#x27;) &#x3D; &#x27;0x471e6d760efa350fb57b30e3eeb04f591c4442767864740e6e67f2f3df2a942b&#x27;
  // then every &quot;indexed&quot; params are putted into topics[1], topics[2], etc ... with a max of 4 indexed params (topics[4])
  // the others params are putted in the data field.

  //----------------------------------
  //          CHECKS/INIT
  //----------------------------------

  /** ensure that the provider exist */
  private _requireProvider() {
    if(!this.provider) {
      this.provider &#x3D; new InfuraProvider(network);
    }
  }

  /** ensure that the org contract exist, (if not it waits until deploy) */
  private async _requireContract() {
    if(!this.contract) {
      this._requireProvider();
      const organizationENS &#x3D; orgNameToEnsDomain(this.query.getValue().org.name);
      let ethAddress &#x3D; await this.getOrganizationEthAddress();
      await new Promise(resolve &#x3D;&gt; {
        if (!ethAddress) {
          // registered
          this.provider.on(getFilterFromTopics(relayer.registryAddress, [
            newOwnerTopic,
            namehash(baseEnsDomain),
            keccak256(getNameFromENS(organizationENS))
          ]), () &#x3D;&gt; {
            this.store.update({deployStep: DeploySteps.registered});
          });

          // resolved
          this.provider.on(getFilterFromTopics(relayer.registryAddress, [newResolverTopic, namehash(organizationENS)]), () &#x3D;&gt; {
            this.store.update({deployStep: DeploySteps.resolved});
          });

          // ready
          this.provider.on(getFilterFromTopics(relayer.resolverAddress, [addrChangedTopic, namehash(organizationENS)]), (log: Log) &#x3D;&gt; {
            ethAddress &#x3D; &#x60;0x${log.data.slice(-40)}&#x60;; // extract address
            this.store.update({deployStep: DeploySteps.ready});
            resolve();
          });
        } else {
          resolve();
        }
      });
      this.provider.removeAllListeners(getFilterFromTopics(relayer.registryAddress, [newOwnerTopic, namehash(baseEnsDomain), keccak256(getNameFromENS(organizationENS))]));
      this.provider.removeAllListeners(getFilterFromTopics(relayer.registryAddress, [newResolverTopic, namehash(organizationENS)]));
      this.provider.removeAllListeners(getFilterFromTopics(relayer.resolverAddress, [addrChangedTopic, namehash(organizationENS)]));
      this.contract &#x3D; new Contract(ethAddress, ORGANIZATION_ABI, this.provider);
    }
  }

  //----------------------------------
  //             GETTERS
  //----------------------------------

  /** Retrieve the Ethereum address of the current org (using it&#x27;s ENS name) */
  public async getOrganizationEthAddress() {
    this._requireProvider();
    const organizationENS &#x3D; orgNameToEnsDomain(this.query.getValue().org.name);
    return this.provider.resolveName(organizationENS);
  }

  /** Retrieve the Ethereum address of a member (using it&#x27;s email and CREATE2 precompute) */
  public async getMemberEthAddress(email: string) {
    this._requireProvider();
    return precomputeEthAddress(emailToEnsDomain(email), this.provider);
  }

  //----------------------------------
  //          LISTENERS
  //----------------------------------

  /** remove all Blockchain event listeners */
  public async removeAllListeners() {
    await this._requireContract();
    this.provider.removeAllListeners(getFilterFromTopics(this.contract.address, [operationCreatedTopic]));
    this.provider.removeAllListeners(getFilterFromTopics(this.contract.address, [quorumUpdatedTopic]));
    this.provider.removeAllListeners(getFilterFromTopics(this.contract.address, [memberAddedTopic]));
    this.provider.removeAllListeners(getFilterFromTopics(this.contract.address, [memberRemovedTopic]));
    this.provider.removeAllListeners(getFilterFromTopics(this.contract.address, [actionApprovedTopic]));
    this.provider.removeAllListeners(getFilterFromTopics(this.contract.address, [actionExecutedTopic]));
  }

  /**
   * Main function of the Blockchain part of Org,
   * it will retrieve the list of operations, pending &amp; approved action
   * and store them in the state, it will also register Blockchain event listeners
   * to ensure that the org data stays up to date.
   */
  public async retrieveDataAndAddListeners() {
    await this._requireContract();

    // check if the listeners were already registered
    if (this.provider.listenerCount() !&#x3D;&#x3D; 0) {
      return;
    }


    // OPERATIONS -----------------------------

    // retrieve hardcoded operation(s)
    const signingDelivery &#x3D; await this.getOperationFromContract(&#x27;0x0000000000000000000000000000000000000000000000000000000000000001&#x27;);
    this.upsertOperation(signingDelivery);

    // retrieve every other operation
    const operationsFilter &#x3D; getFilterFromTopics(this.contract.address, [operationCreatedTopic]);
    const operationLogs &#x3D; await this.provider.getLogs(operationsFilter);
    const operationIds &#x3D; operationLogs.map(operationLog &#x3D;&gt; operationLog.topics[1]);
    operationIds.forEach(operationId &#x3D;&gt;
      this.getOperationFromContract(operationId).then(operation &#x3D;&gt; this.upsertOperation(operation))
    );

    // listen for operation created
    this.provider.on(operationsFilter, async (log: Log) &#x3D;&gt; {
      const operation &#x3D; await this.getOperationFromContract(log.topics[1]);
      this.upsertOperation(operation);
    });

    // listen for quorum updates
    const quorumFilter &#x3D; getFilterFromTopics(this.contract.address, [quorumUpdatedTopic]);
    this.provider.on(quorumFilter,(log: Log) &#x3D;&gt; {
      const operationId &#x3D; log.topics[1];
      const quorum &#x3D; BigNumber.from(log.topics[2]).toNumber();
      this.updateOperationQuorum(operationId, quorum);
    });

    // listen for member added
    const memberAddedFilter &#x3D; getFilterFromTopics(this.contract.address, [memberAddedTopic]);
    this.provider.on(memberAddedFilter, (log: Log) &#x3D;&gt; {
      const operationId &#x3D; log.topics[1];
      const memberEthAddress &#x3D; log.topics[2];
      console.log(&#x60;member ${memberEthAddress} added to op ${operationId}&#x60;); // TODO issue#762 : link blockchain user address to org members, then call &#x27;addOperationMember()&#x27;
    });

    // listen for member removed
    const memberRemovedFilter &#x3D; getFilterFromTopics(this.contract.address, [memberRemovedTopic]);
    this.provider.on(memberRemovedFilter, (log: Log) &#x3D;&gt; {
      const operationId &#x3D; log.topics[1];
      const memberEthAddress &#x3D; log.topics[2];
      console.log(&#x60;member ${memberEthAddress} removed from op ${operationId}&#x60;); // TODO issue#762 : link blockchain user address to org members, then call &#x27;removeOperationMember()&#x27;
    });


    // ACTIONS -----------------------------

    // get all actions
    const actionsFilter &#x3D; getFilterFromTopics(this.contract.address, [actionApprovedTopic]);
    const actionLogs &#x3D; await this.provider.getLogs(actionsFilter);
    const actionIds &#x3D; actionLogs.map(log &#x3D;&gt; log.topics[1]); // topics[1] contain the actions ids : &quot;ActionApproved( **bytes32 indexed actionId**, address indexed member);&quot;
    actionIds
      .reduce((acc, curr) &#x3D;&gt; acc.includes(curr) ? acc : [...acc, curr], []) // remove duplicate entries
      .forEach(actionId &#x3D;&gt; this.getActionFromContract(actionId).then(action &#x3D;&gt; this.upsertAction(action)));

    // listen for approvals
    this.provider.on(actionsFilter, async(log: Log) &#x3D;&gt; {
      const action &#x3D; await this.getActionFromContract(log.topics[1]);
      this.upsertAction(action);
    });

    // listen for execution
    const executeFilter &#x3D; getFilterFromTopics(this.contract.address, [actionExecutedTopic]);
    this.provider.on(executeFilter, async(log: Log) &#x3D;&gt; {
      const action &#x3D; await this.getActionFromContract(log.topics[1]);
      this.upsertAction(action);
    });
  }

  //----------------------------------
  //          OPERATIONS
  //----------------------------------

  /**
   * Retrieve the minimal infos of an operation from the blockchain,
   * then enrich those infos to return a full &#x60;OrganizationOperation&#x60; object
   */
  public async getOperationFromContract(operationId: string) {
    await this._requireContract();

    const rawOperation: RawOperation &#x3D; await this.contract.getOperation(operationId);
    const operation: OrganizationOperation &#x3D; {
      id: operationId,
      name: rawOperation.name,
      quorum: BigNumber.from(rawOperation.quorum).toNumber(),
      members: [],
    };

    // re construct members list
    const promises: Promise&lt;number&gt;[] &#x3D; [];
    this.query.getValue().org.members
      .filter(member &#x3D;&gt; !this.permissionsQuery.isUserSuperAdmin(member.uid))
      .forEach(member &#x3D;&gt; {
        const promise &#x3D; precomputeEthAddress(emailToEnsDomain(member.email), this.provider)
          .then((ethAddress): boolean &#x3D;&gt; this.contract.isWhitelisted(ethAddress, operationId))
          .then(isWhiteListed &#x3D;&gt; isWhiteListed ? operation.members.push(member) : -1);
        promises.push(promise);
      });

    await Promise.all(promises);
    return operation;
  }

  /** create a newOperation in the state, or update it if it already exists */
  private async upsertOperation(newOperation: OrganizationOperation) {
    let { operations } &#x3D; this.query.getValue().org; // get every operations

    if(!operations) {
      operations &#x3D; [];
    }

    // add the updated operation to the operations list
    // we could not use &#x60;operations.push(newOperation)&#x60; directly otherwise the operation will have been duplicated
    const newOperations &#x3D; [
      ...operations.filter(currentOperation &#x3D;&gt; currentOperation.id !&#x3D;&#x3D; newOperation.id),// get all operations except the one we want to upsert
      newOperation
    ]
    // update the store
    this.store.update(state &#x3D;&gt; {
      return {
        ...state, // keep everything of the state
        org: { ...state.org, operations: newOperations }, // update only the operations array
      }
    });
  }

  /** modify the quorum of an org in the state */
  updateOperationQuorum(id: string, newQuorum: number) {
    const operation &#x3D; this.query.getOperationById(id);
    if (!operation) throw new Error(&#x27;This operation doesn\&#x27;t exists&#x27;);
    return this.upsertOperation({
      ...operation,
      quorum: newQuorum
    });
  }

  /** add a member to an operation in the state */
  addOperationMember(id: string, newMember: OrganizationMember) {
    const operation &#x3D; this.query.getOperationById(id);
    if (!operation) throw new Error(&#x27;This operation doesn\&#x27;t exists&#x27;);

    const memberExists &#x3D; operation.members.some(member &#x3D;&gt; member.uid &#x3D;&#x3D;&#x3D; newMember.uid);
    if (!!memberExists) throw new Error(&#x27;This member is already a signer of this operation&#x27;);

    return this.upsertOperation({
      ...operation,
      members: [...operation.members, newMember]
    });
  }

  /** remove a member form an operation in the state */
  removeOperationMember(id: string, memberToRemove: OrganizationMember) {
    const operation &#x3D; this.query.getOperationById(id);
    if (!operation) throw new Error(&#x27;This operation doesn\&#x27;t exists&#x27;);

    const members &#x3D; operation.members.filter(member &#x3D;&gt; member.uid !&#x3D;&#x3D; memberToRemove.uid);
    const newOperation &#x3D; { ...operation, members };

    return this.upsertOperation(newOperation);
  }

  //----------------------------------
  //              ACTIONS
  //----------------------------------

  public async getActionFromContract(actionId: string) {
    await this._requireContract();

    const rawAction: RawAction &#x3D; await this.contract.getAction(actionId);
    const action: OrganizationAction &#x3D; {
      id: actionId,
      opId: rawAction.operationId,
      name: &#x27;[Unknown Action]&#x27;,
      isApproved: rawAction.executed,
      signers: [],
    };

    // retrieve approval date if the action was executed
    const approvalDate &#x3D; await this.getActionApprovalDate(actionId);
    if (!! approvalDate) {
      action.approvalDate &#x3D; approvalDate;
    }

    // retrieve the name from firestore
    const fireAction &#x3D; await this.db.collection(&#x27;actions&#x27;).doc(actionId).get().toPromise();
    if (!!fireAction.data() &amp;&amp; !!fireAction.data().name) {
      action.name &#x3D; fireAction.data().name;
    }

    // re construct signer list
    const promises: Promise&lt;number&gt;[] &#x3D; [];
    this.query.getValue().org.members
      .forEach(member &#x3D;&gt; {
        const promise &#x3D; precomputeEthAddress(emailToEnsDomain(member.email), this.provider)
          .then((ethAddress): boolean &#x3D;&gt; this.contract.hasApprovedAction(ethAddress, actionId))
          .then(hasApproved &#x3D;&gt; hasApproved ? action.signers.push(member) : -1);
        promises.push(promise);
      });

    await Promise.all(promises);

    return action;
  }

  /** retrieve approval date if the action was executed */
  public async getActionApprovalDate(actionId: string) {
    await this._requireContract();
    return this.provider.getLogs(getFilterFromTopics(this.contract.address, [actionExecutedTopic, actionId])).then(logs &#x3D;&gt; {
      if (!!logs[0]) {
        return this.provider.getBlock(logs[0].blockHash);
      }
    }).then(block &#x3D;&gt; {
      if (!!block) {
        const date &#x3D; new Date(block.timestamp * 1000);
        const month &#x3D; date.getMonth() + 1;
         return &#x60;${date.getFullYear()}/${month &lt; 10 ? &#x27;0&#x27; + month : month}/${date.getDate()}&#x60;
      }
    });
  }

  /** create a newOperation in the state, or update it if it already exists */
  public upsertAction(newAction: OrganizationAction) {
    let { actions } &#x3D; this.query.getValue().org; // get every actions

    if(!actions) {
      actions &#x3D; [];
    }

    // add the updated action to the actions list
    // we could not use &#x60;actions.push(newOperation)&#x60; directly otherwise the action will have been duplicated
    const newActions &#x3D; [
      ...actions.filter(currentAction &#x3D;&gt; currentAction.id !&#x3D;&#x3D; newAction.id),// get all actions except the one we want to upsert
      newAction
    ]
    // update the store
    this.store.update(state &#x3D;&gt; {
      return {
        ...state, // keep everything of the state
        org: { ...state.org, actions: newActions }, // update only the actions array
      }
    });
  }

  /** Lets an organization request access to an application */
  public requestAccessToApp(orgId: string, appId: string): Promise&lt;any&gt; {
    const docRef &#x3D; this.db.collection(&#x27;app-requests&#x27;).doc(orgId).ref;

    return this.db.firestore.runTransaction(async tx &#x3D;&gt; {
      const doc &#x3D; await tx.get(docRef);

      if (!doc.exists) {
        return tx.set(docRef, { [appId]: &#x27;requested&#x27; });
      } else {
        return tx.update(docRef, { [appId]: &#x27;requested&#x27; });
      }
    });
  }
}
</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'RawOperation.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
